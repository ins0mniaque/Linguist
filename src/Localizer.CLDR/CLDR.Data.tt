<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(TargetDir)Localizer.dll" #>
<#@ assembly name="$(TargetDir)Localizer.CLDR.dll" #>
<#@ import namespace="Localizer.CLDR" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
using System.Globalization;

using Localizer.Pluralization;

namespace Localizer.CLDR
{
<#
    var cardinals = XDocument.Load ( Host.ResolvePath ( "CLDR/common/supplemental/plurals.xml"  ) );
    var ordinals  = XDocument.Load ( Host.ResolvePath ( "CLDR/common/supplemental/ordinals.xml" ) );

    var cardinalRuleSet = PluralRules.Parse ( cardinals );
    var ordinalRuleSet  = PluralRules.Parse ( ordinals  );

    WriteLookup ( cardinalRuleSet, "CardinalRuleSet" );
    WriteLine   ( string.Empty );
    WriteLookup ( ordinalRuleSet,  "OrdinalRuleSet"  );

    WritePluralRules ( cardinalRuleSet, true  );
    WritePluralRules ( ordinalRuleSet,  false );
#>}<#+
    private void WriteLookup ( PluralRules [ ] pluralRulesSet, string lookupName )
    {
#>
    internal static class <#= lookupName #>
    {
        public static PluralFormSelector For ( CultureInfo culture )
        {
<#+
        var defaultRules = (PluralRules) null;
        var hasSubtags   = false;
        foreach ( var pluralRules in pluralRulesSet )
        {
            if ( pluralRules.Name.IndexOf ( "default", StringComparison.OrdinalIgnoreCase ) >= 0 )
                defaultRules = pluralRules;

            foreach ( var locale in pluralRules.Locales )
                if ( locale.IndexOf ( '-' ) >= 0 )
                    hasSubtags = true;
        }

        if ( hasSubtags )
        {
#>
            switch ( culture.Name )
            {
<#+
            foreach ( var pluralRules in pluralRulesSet )
            {
                if ( pluralRules == defaultRules )
                    continue;

                WriteLookupCases ( pluralRules, Array.FindAll ( pluralRules.Locales, locale => locale.IndexOf ( '-' ) >= 0 ), 8 );
            }
#>
            }

<#+
        }
#>
            switch ( culture.TwoLetterISOLanguageName )
            {
<#+
        foreach ( var pluralRules in pluralRulesSet )
        {
            if ( pluralRules == defaultRules )
                continue;

            WriteLookupCases ( pluralRules, Array.FindAll ( pluralRules.Locales, locale => locale.IndexOf ( '-' ) < 0 ), 5 );
        }
#>
                default    : return <#= defaultRules.Name #>.Instance;
            }
        }
    }
<#+
    }

    private void WriteLookupCases ( PluralRules pluralRules, string [ ] locales, int padding )
    {
        foreach ( var locale in locales )
        {
#>
                case <#= string.Format ( "{0,-" + padding + "}", "\"" + locale + "\"" ) #> : return <#= pluralRules.Name #>.Instance;
<#+
        }
    }

    private void WritePluralRules ( PluralRules [ ] pluralRulesSet, bool explicitRules )
    {
        foreach ( var pluralRules in pluralRulesSet )
        {
#>

    // Locales: <#= string.Join ( ", ", pluralRules.Locales ) #>
    internal class <#= pluralRules.Name #> : PluralFormSelector
    {
        public static readonly <#= pluralRules.Name #> Instance = new <#= pluralRules.Name #> ( );

        private <#= pluralRules.Name #> ( ) : base ( PluralForm.<#= pluralRules.PluralForm.ToString ( ).Replace ( ", ", " | PluralForm." ) #> ) { }

        public override PluralForm SelectPluralForm ( decimal number, PluralForm availablePluralForms )
        {
<#+
            var operands = new HashSet < string > ( );

            if ( explicitRules )
            {
                operands.Add ( "i" );
                operands.Add ( "v" );
            }

            foreach ( var operand in pluralRules.Operands )
                operands.Add ( operand );

            foreach ( var operand in operands )
            {
#>
            var <#= operand #> = number.<#= operand #> ( );
<#+
            }

            if ( explicitRules )
                WriteExplicitRules ( pluralRules.PluralForm );

            foreach ( var pluralRule in pluralRules.Rules )
            {
#>

            // "<#= pluralRule.PluralForm.ToString ( ).ToLowerInvariant ( ) #>": <#= pluralRule.RuleCode #>
<#+
                WriteSamples ( "integer", pluralRule.IntegerSamples );
                WriteSamples ( "decimal", pluralRule.DecimalSamples );
#>
            if ( <#= pluralRule.Rule #> )
                return PluralForm.<#= pluralRule.PluralForm #>;
<#+
            }
#>

            // "<#= pluralRules.DefaultRule.PluralForm.ToString ( ).ToLowerInvariant ( ) #>"
<#+
            WriteSamples ( "integer", pluralRules.DefaultRule.IntegerSamples );
            WriteSamples ( "decimal", pluralRules.DefaultRule.DecimalSamples );
#>
            return PluralForm.Other;
        }
    }
<#+
        }
    }

    private void WriteExplicitRules ( Localizer.PluralForm pluralForms )
    {
#>

            // Explicit "0" rule
            if ( availablePluralForms.HasBitMask ( PluralForm.ExplicitZero ) )
            {
                if ( ExplicitRule.Zero ( i, v ) )
                    return PluralForm.ExplicitZero;
            }
<#+
        if ( ( pluralForms & Localizer.PluralForm.Zero ) != Localizer.PluralForm.Zero )
        {
#>
            // Explicit "0" rule "zero" fallback
            else if ( availablePluralForms.HasBitMask ( PluralForm.Zero ) )
            {
                if ( ExplicitRule.Zero ( i, v ) )
                    return PluralForm.Zero;
            }
<#+
        }
#>

            // Explicit "1" rule
            if ( availablePluralForms.HasBitMask ( PluralForm.ExplicitOne ) )
            {
                if ( ExplicitRule.One ( i, v ) )
                    return PluralForm.ExplicitOne;
            }
<#+
        if ( ( pluralForms & Localizer.PluralForm.One ) != Localizer.PluralForm.One )
        {
#>
            // Explicit "1" rule "one" fallback
            else if ( availablePluralForms.HasBitMask ( PluralForm.One ) )
            {
                if ( ExplicitRule.One ( i, v ) )
                    return PluralForm.One;
            }
<#+
        }
    }

    private void WriteSamples ( string name, string [ ] samples )
    {
        if ( samples != null && samples.Length > 0 )
        {
#>
            //   @<#= name #>: <#= string.Join ( ", ", samples ) #>
<#+
        }
    }
#>