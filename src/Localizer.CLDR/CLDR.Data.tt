<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(TargetDir)Localizer.dll" #>
<#@ assembly name="$(TargetDir)Localizer.CLDR.dll" #>
<#@ import namespace="Localizer.CLDR" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
using System.Globalization;

using Localizer.Pluralization;

namespace Localizer.CLDR
{
    internal static class PluralRuleSets
    {
        public static PluralFormSelector GetCardinalRuleSet ( CultureInfo culture )
        {
            return null;
        }

        public static PluralFormSelector GetOrdinalRuleSet ( CultureInfo culture )
        {
            return null;
        }

        public static PluralFormRangeSelector GetRangeRuleSet ( CultureInfo culture )
        {
            return null;
        }
    }
<#
    var plurals = XDocument.Load ( Host.ResolvePath ( "CLDR/common/supplemental/plurals.xml" ) );

    var names = new Dictionary < string, int > ( );

    foreach ( var pluralRuleSet in PluralRules.Parse ( plurals ) )
    {
        if ( pluralRuleSet.Rules.Length == 0 && pluralRuleSet.PluralForm == Localizer.PluralForm.Other )
        {
#>

    // Locales: <#= string.Join ( ", ", pluralRuleSet.Locales ) #>
    public class DefaultCardinalRuleSet : PluralFormSelector
    {
        public DefaultCardinalRuleSet ( ) : base ( PluralForm.Other ) { }

        public override PluralForm SelectPluralForm ( decimal number, PluralForm availablePluralForms )
        {
            var i = number.i ( );
            var v = number.v ( );
<#
            WriteExplicitRules ( pluralRuleSet.PluralForm );
#>

            return PluralForm.Other;
        }
    }
<#
            continue;
        }

        var name = "CardinalRuleSet" + pluralRuleSet.PluralForm.ToString ( ).Replace ( ", ", string.Empty );
        int index;
        if ( ! names.TryGetValue ( name, out index ) )
            index = -1;

        names [ name ] = ++index;

        name += (char) ( 'A' + index );
#>

    // Locales: <#= string.Join ( ", ", pluralRuleSet.Locales ) #>
    public class <#= name #> : PluralFormSelector
    {
        public <#= name #> ( ) : base ( PluralForm.<#= pluralRuleSet.PluralForm.ToString ( ).Replace ( ", ", " | PluralForm." ) #> ) { }

        public override PluralForm SelectPluralForm ( decimal number, PluralForm availablePluralForms )
        {
<#
        var operands = new HashSet < string > ( ) { "i", "v" };
        foreach ( var operand in pluralRuleSet.Operands )
            operands.Add ( operand );

        foreach ( var operand in operands )
        {
#>
            var <#= operand #> = number.<#= operand #> ( );
<#
        }

        WriteExplicitRules ( pluralRuleSet.PluralForm );

        foreach ( var pluralRule in pluralRuleSet.Rules )
        {
#>

            // "<#= pluralRule.PluralForm.ToString ( ).ToLowerInvariant ( ) #>": <#= pluralRule.RuleCode #>
<#
            WriteSamples ( "integer", pluralRule.IntegerSamples );
            WriteSamples ( "decimal", pluralRule.DecimalSamples );
#>
            if ( <#= pluralRule.Rule #> )
                return PluralForm.<#= pluralRule.PluralForm #>;
<#
        }
#>

            return PluralForm.Other;
        }
    }
<#
    }
#>
}<#+
    private void WriteExplicitRules ( Localizer.PluralForm pluralForms )
    {
#>

            // Explicit "0" rule
            if ( availablePluralForms.HasBitMask ( PluralForm.ExplicitZero ) )
            {
                if ( ExplicitRule.Zero ( i, v ) )
                    return PluralForm.ExplicitZero;
            }
<#+
        if ( ( pluralForms & Localizer.PluralForm.Zero ) != Localizer.PluralForm.Zero )
        {
#>
            // Explicit "0" rule "zero" fallback
            else if ( availablePluralForms.HasBitMask ( PluralForm.Zero ) )
            {
                if ( ExplicitRule.Zero ( i, v ) )
                    return PluralForm.Zero;
            }
<#+
        }
#>

            // Explicit "1" rule
            if ( availablePluralForms.HasBitMask ( PluralForm.ExplicitOne ) )
            {
                if ( ExplicitRule.One ( i, v ) )
                    return PluralForm.ExplicitOne;
            }
<#+
        if ( ( pluralForms & Localizer.PluralForm.One ) != Localizer.PluralForm.One )
        {
#>
            // Explicit "1" rule "one" fallback
            else if ( availablePluralForms.HasBitMask ( PluralForm.One ) )
            {
                if ( ExplicitRule.One ( i, v ) )
                    return PluralForm.One;
            }
<#+
        }
    }

    private void WriteSamples ( string name, string [ ] samples )
    {
        if ( samples != null && samples.Length > 0 )
        {
#>
            //   @<#= name #>: <#= string.Join ( ", ", samples ) #>
<#+
        }
    }
#>