<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(TargetDir)Localizer.dll" #>
<#@ assembly name="$(TargetDir)Localizer.CLDR.dll" #>
<#@ import namespace="Localizer.CLDR" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
using System.Globalization;

using Localizer.Pluralization;

namespace Localizer.CLDR
{
<#
    var cardinals = XDocument.Load ( Host.ResolvePath ( "CLDR/common/supplemental/plurals.xml"  ) );
    var ordinals  = XDocument.Load ( Host.ResolvePath ( "CLDR/common/supplemental/ordinals.xml" ) );
    var ranges    = XDocument.Load ( Host.ResolvePath ( "CLDR/common/supplemental/pluralRanges.xml" ) );

    var cardinalRuleSet = PluralRules .Parse ( cardinals );
    var ordinalRuleSet  = PluralRules .Parse ( ordinals  );
    var rangeRuleSet    = PluralRanges.Parse ( ranges    );

    WriteLookup ( cardinalRuleSet, "CardinalRuleSet" );
    WriteLine   ( string.Empty );
    WriteLookup ( ordinalRuleSet,  "OrdinalRuleSet"  );
    WriteLine   ( string.Empty );
    WriteLookup ( rangeRuleSet,    "RangeRuleSet"    );

    WritePluralRules  ( cardinalRuleSet, true  );
    WritePluralRules  ( ordinalRuleSet,  false );
    WritePluralRanges ( rangeRuleSet );
#>}<#+
    private void WriteLookup ( PluralRules [ ] pluralRulesSet, string lookupName )
    {
#>
    internal static class <#= lookupName #>
    {
        public static PluralFormSelector For ( CultureInfo culture )
        {
<#+
        var defaultRules = (PluralRules) null;
        var hasSubtags   = false;
        foreach ( var pluralRules in pluralRulesSet )
        {
            if ( pluralRules.Name.IndexOf ( "default", StringComparison.OrdinalIgnoreCase ) >= 0 )
                defaultRules = pluralRules;

            foreach ( var locale in pluralRules.Locales )
                if ( locale.IndexOf ( '-' ) >= 0 )
                    hasSubtags = true;
        }

        if ( hasSubtags )
        {
#>
            switch ( culture.Name )
            {
<#+
            foreach ( var pluralRules in pluralRulesSet )
            {
                if ( pluralRules == defaultRules )
                    continue;

                WriteLookupCases ( pluralRules.Name, Array.FindAll ( pluralRules.Locales, locale => locale.IndexOf ( '-' ) >= 0 ), 8 );
            }
#>
            }

<#+
        }
#>
            switch ( culture.TwoLetterISOLanguageName )
            {
<#+
        foreach ( var pluralRules in pluralRulesSet )
        {
            if ( pluralRules == defaultRules )
                continue;

            WriteLookupCases ( pluralRules.Name, Array.FindAll ( pluralRules.Locales, locale => locale.IndexOf ( '-' ) < 0 ), 5 );
        }
#>
                default    : return <#= defaultRules.Name #>.Instance;
            }
        }
    }
<#+
    }

    private void WriteLookup ( PluralRanges [ ] pluralRangesSet, string lookupName )
    {
#>
    internal static class <#= lookupName #>
    {
        public static PluralFormRangeSelector For ( CultureInfo culture )
        {
<#+
        var defaultRanges = (PluralRanges) null;
        var hasSubtags    = false;
        foreach ( var pluralRanges in pluralRangesSet )
        {
            if ( pluralRanges.Name.IndexOf ( "default", StringComparison.OrdinalIgnoreCase ) >= 0 )
                defaultRanges = pluralRanges;

            foreach ( var locale in pluralRanges.Locales )
                if ( locale.IndexOf ( '-' ) >= 0 )
                    hasSubtags = true;
        }

        if ( hasSubtags )
        {
#>
            switch ( culture.Name )
            {
<#+
            foreach ( var pluralRanges in pluralRangesSet )
            {
                if ( pluralRanges == defaultRanges )
                    continue;

                WriteLookupCases ( pluralRanges.Name, Array.FindAll ( pluralRanges.Locales, locale => locale.IndexOf ( '-' ) >= 0 ), 8 );
            }
#>
            }

<#+
        }
#>
            switch ( culture.TwoLetterISOLanguageName )
            {
<#+
        foreach ( var pluralRanges in pluralRangesSet )
        {
            if ( pluralRanges == defaultRanges )
                continue;

            WriteLookupCases ( pluralRanges.Name, Array.FindAll ( pluralRanges.Locales, locale => locale.IndexOf ( '-' ) < 0 ), 5 );
        }
#>
                default    : return <#= defaultRanges.Name #>.Instance;
            }
        }
    }
<#+
    }

    private void WriteLookupCases ( string className, string [ ] locales, int padding )
    {
        foreach ( var locale in locales )
        {
#>
                case <#= string.Format ( "{0,-" + padding + "}", "\"" + locale + "\"" ) #> : return <#= className #>.Instance;
<#+
        }
    }

    private void WritePluralRules ( PluralRules [ ] pluralRulesSet, bool explicitRules )
    {
        foreach ( var pluralRules in pluralRulesSet )
        {
#>

    // Locales: <#= string.Join ( ", ", pluralRules.Locales ) #>
    internal class <#= pluralRules.Name #> : PluralFormSelector
    {
        public static readonly <#= pluralRules.Name #> Instance = new <#= pluralRules.Name #> ( );

        private <#= pluralRules.Name #> ( ) : base ( PluralForm.<#= pluralRules.PluralForm.ToString ( ).Replace ( ", ", " | PluralForm." ) #> ) { }

        public override PluralForm SelectPluralForm ( decimal number, PluralForm availablePluralForms )
        {
<#+
            var operands = new HashSet < string > ( );

            if ( explicitRules )
            {
                operands.Add ( "i" );
                operands.Add ( "v" );
            }

            foreach ( var operand in pluralRules.Operands )
                operands.Add ( operand );

            foreach ( var operand in operands )
            {
#>
            var <#= operand #> = number.<#= operand #> ( );
<#+
            }

            if ( explicitRules )
                WriteExplicitRules ( pluralRules.PluralForm );

            foreach ( var pluralRule in pluralRules.Rules )
            {
#>

            // "<#= pluralRule.PluralForm.ToString ( ).ToLowerInvariant ( ) #>": <#= pluralRule.RuleCode #>
<#+
                WriteSamples ( "integer", pluralRule.IntegerSamples );
                WriteSamples ( "decimal", pluralRule.DecimalSamples );
#>
            if ( <#= pluralRule.Rule #> )
                return PluralForm.<#= pluralRule.PluralForm #>;
<#+
            }
#>

            // "<#= pluralRules.DefaultRule.PluralForm.ToString ( ).ToLowerInvariant ( ) #>"
<#+
            WriteSamples ( "integer", pluralRules.DefaultRule.IntegerSamples );
            WriteSamples ( "decimal", pluralRules.DefaultRule.DecimalSamples );
#>
            return PluralForm.Other;
        }
    }
<#+
        }
    }

    private void WritePluralRanges ( PluralRanges [ ] pluralRangesSet )
    {
        foreach ( var pluralRanges in pluralRangesSet )
        {
#>

    // Locales: <#= string.Join ( ", ", pluralRanges.Locales ) #>
    internal class <#= pluralRanges.Name #> : PluralFormRangeSelector
    {
        public static readonly <#= pluralRanges.Name #> Instance = new <#= pluralRanges.Name #> ( );

        private <#= pluralRanges.Name #> ( ) { }

        public override PluralForm SelectPluralForm ( PluralForm start, PluralForm end )
        {
<#+
            foreach ( var pluralRange in pluralRanges.Ranges )
            {
                if ( pluralRange.End == pluralRange.Result )
                    continue;
#>
            if ( start == PluralForm.<#= pluralRange.Start #> && end == PluralForm.<#= pluralRange.End #> )
                return PluralForm.<#= pluralRange.Result #>;

<#+
            }
#>
            return end;
        }
    }
<#+
        }
    }

    private void WriteExplicitRules ( Localizer.PluralForm pluralForms )
    {
#>

            // Explicit "0" rule
            if ( availablePluralForms.HasBitMask ( PluralForm.ExplicitZero ) )
            {
                if ( ExplicitRule.Zero ( i, v ) )
                    return PluralForm.ExplicitZero;
            }
<#+
        if ( ( pluralForms & Localizer.PluralForm.Zero ) != Localizer.PluralForm.Zero )
        {
#>
            // Explicit "0" rule "zero" fallback
            else if ( availablePluralForms.HasBitMask ( PluralForm.Zero ) )
            {
                if ( ExplicitRule.Zero ( i, v ) )
                    return PluralForm.Zero;
            }
<#+
        }
#>

            // Explicit "1" rule
            if ( availablePluralForms.HasBitMask ( PluralForm.ExplicitOne ) )
            {
                if ( ExplicitRule.One ( i, v ) )
                    return PluralForm.ExplicitOne;
            }
<#+
        if ( ( pluralForms & Localizer.PluralForm.One ) != Localizer.PluralForm.One )
        {
#>
            // Explicit "1" rule "one" fallback
            else if ( availablePluralForms.HasBitMask ( PluralForm.One ) )
            {
                if ( ExplicitRule.One ( i, v ) )
                    return PluralForm.One;
            }
<#+
        }
    }

    private void WriteSamples ( string name, string [ ] samples )
    {
        if ( samples != null && samples.Length > 0 )
        {
#>
            //   @<#= name #>: <#= string.Join ( ", ", samples ) #>
<#+
        }
    }
#>